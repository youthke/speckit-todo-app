package auth

import (
	"context"
	"errors"
	"time"

	"golang.org/x/oauth2"
	"gorm.io/gorm"
	"todo-app/models"
)

// OAuthService handles OAuth flow operations
type OAuthService struct {
	db           *gorm.DB
	googleConfig *GoogleOAuthConfig
}

// NewOAuthService creates a new OAuth service
func NewOAuthService(db *gorm.DB, googleConfig *GoogleOAuthConfig) *OAuthService {
	return &OAuthService{
		db:           db,
		googleConfig: googleConfig,
	}
}

// InitiateOAuthFlowResult represents the result of initiating OAuth flow
type InitiateOAuthFlowResult struct {
	AuthURL    string `json:"auth_url"`
	StateToken string `json:"state_token"`
}

// InitiateOAuthFlow starts the OAuth flow by creating state and generating auth URL
func (s *OAuthService) InitiateOAuthFlow(ctx context.Context, redirectURI string) (*InitiateOAuthFlowResult, error) {
	// Create OAuth state with PKCE
	oauthState, err := models.CreateAndSave(s.db, redirectURI)
	if err != nil {
		return nil, err
	}

	// Generate PKCE challenge
	pkceChallenge := oauthState.GeneratePKCEChallenge()

	// Get authorization URL
	authURL := s.googleConfig.GetAuthURL(oauthState.StateToken, pkceChallenge)

	return &InitiateOAuthFlowResult{
		AuthURL:    authURL,
		StateToken: oauthState.StateToken,
	}, nil
}

// OAuthCallbackResult represents the result of processing OAuth callback
type OAuthCallbackResult struct {
	User        *models.User                  `json:"user"`
	Session     *models.AuthenticationSession `json:"session"`
	RedirectURI string                        `json:"redirect_uri"`
	IsNewUser   bool                          `json:"is_new_user"`
}

// ProcessOAuthCallback handles the OAuth callback from Google
func (s *OAuthService) ProcessOAuthCallback(ctx context.Context, code, state string) (*OAuthCallbackResult, error) {
	// Validate and consume OAuth state
	validationResult, err := models.ValidateAndConsume(s.db, state)
	if err != nil {
		return nil, err
	}

	if !validationResult.Valid {
		return nil, errors.New("invalid or expired OAuth state: " + validationResult.Error)
	}

	// Exchange code for token with PKCE verifier
	token, err := s.googleConfig.ExchangeCode(ctx, code, validationResult.PKCEVerifier)
	if err != nil {
		return nil, errors.New("failed to exchange authorization code: " + err.Error())
	}

	// Get user info from Google
	userInfo, err := s.googleConfig.GetUserInfo(ctx, token.AccessToken)
	if err != nil {
		return nil, errors.New("failed to get user info from Google: " + err.Error())
	}

	// Find or create user
	user, isNewUser, err := s.findOrCreateUser(userInfo)
	if err != nil {
		return nil, err
	}

	// Create authentication session
	session, err := s.createOAuthSession(user.ID, token)
	if err != nil {
		return nil, err
	}

	return &OAuthCallbackResult{
		User:        user,
		Session:     session,
		RedirectURI: validationResult.RedirectURI,
		IsNewUser:   isNewUser,
	}, nil
}

// findOrCreateUser finds an existing user or creates a new one from Google user info
func (s *OAuthService) findOrCreateUser(userInfo *GoogleUserInfo) (*models.User, bool, error) {
	var user models.User
	isNewUser := false

	// Try to find user by Google ID
	result := s.db.Where("google_id = ?", userInfo.ID).First(&user)
	if result.Error == nil {
		// User exists with this Google ID
		return &user, false, nil
	}

	if !errors.Is(result.Error, gorm.ErrRecordNotFound) {
		return nil, false, result.Error
	}

	// Try to find user by email (for account linking)
	result = s.db.Where("email = ?", userInfo.Email).First(&user)
	if result.Error == nil {
		// User exists with this email - link Google account
		now := time.Now()
		err := user.LinkGoogleAccount(userInfo.ID, now)
		if err != nil {
			return nil, false, err
		}

		// Save the linked account
		if err := s.db.Save(&user).Error; err != nil {
			return nil, false, err
		}

		return &user, false, nil
	}

	if !errors.Is(result.Error, gorm.ErrRecordNotFound) {
		return nil, false, result.Error
	}

	// Create new user
	now := time.Now()
	newUser := models.User{
		Email:          userInfo.Email,
		Name:           userInfo.Name,
		GoogleID:       userInfo.ID,
		OAuthProvider:  "google",
		OAuthCreatedAt: &now,
		IsActive:       true,
	}

	if err := s.db.Create(&newUser).Error; err != nil {
		return nil, false, err
	}

	isNewUser = true
	return &newUser, isNewUser, nil
}

// createOAuthSession creates a new authentication session with OAuth tokens
func (s *OAuthService) createOAuthSession(userID uint, token *oauth2.Token) (*models.AuthenticationSession, error) {
	// Generate session token (JWT will be generated by JWT service)
	sessionToken := generateSessionToken()

	// Calculate expiration times
	sessionExpiresAt := time.Now().Add(24 * time.Hour)
	tokenExpiresAt := token.Expiry

	// Create session
	session := models.NewOAuthSession(
		userID,
		sessionToken,
		token.AccessToken,
		token.RefreshToken,
		tokenExpiresAt,
		sessionExpiresAt,
		"", // User agent (will be set by handler)
		"", // IP address (will be set by handler)
	)

	if err := s.db.Create(session).Error; err != nil {
		return nil, err
	}

	return session, nil
}

// RefreshOAuthToken refreshes the OAuth access token using refresh token
func (s *OAuthService) RefreshOAuthToken(ctx context.Context, sessionID string) (*models.AuthenticationSession, error) {
	var session models.AuthenticationSession

	// Find the session
	result := s.db.Where("id = ?", sessionID).First(&session)
	if result.Error != nil {
		return nil, result.Error
	}

	// Check if session is expired
	if session.IsExpired() {
		return nil, errors.New("session has expired")
	}

	// Check if we have a refresh token
	if session.RefreshToken == "" {
		return nil, errors.New("no refresh token available")
	}

	// Refresh the token with Google
	newToken, err := s.googleConfig.RefreshToken(ctx, session.RefreshToken)
	if err != nil {
		return nil, errors.New("failed to refresh token: " + err.Error())
	}

	// Update session with new tokens
	err = session.UpdateOAuthTokens(newToken.AccessToken, newToken.RefreshToken, newToken.Expiry)
	if err != nil {
		return nil, err
	}

	// Save updated session
	if err := s.db.Save(&session).Error; err != nil {
		return nil, err
	}

	return &session, nil
}

// RevokeOAuthAccess revokes OAuth access and terminates sessions
func (s *OAuthService) RevokeOAuthAccess(ctx context.Context, accessToken string) error {
	// Revoke token with Google
	if err := s.googleConfig.RevokeToken(ctx, accessToken); err != nil {
		return err
	}

	// Find and delete sessions with this access token
	result := s.db.Where("access_token = ?", accessToken).Delete(&models.AuthenticationSession{})
	if result.Error != nil {
		return result.Error
	}

	return nil
}

// HandleRevocationWebhook processes OAuth revocation webhook from Google
func (s *OAuthService) HandleRevocationWebhook(ctx context.Context, token string) error {
	// Find sessions with this token (could be access or refresh token)
	var sessions []models.AuthenticationSession

	result := s.db.Where("access_token = ? OR refresh_token = ?", token, token).Find(&sessions)
	if result.Error != nil {
		return result.Error
	}

	// Delete all affected sessions
	for _, session := range sessions {
		if err := s.db.Delete(&session).Error; err != nil {
			// Log error but continue with other sessions
			continue
		}
	}

	return nil
}

// generateSessionToken generates a temporary session token
// This will be replaced with a proper JWT by the JWT service
func generateSessionToken() string {
	return "temp_session_token_" + time.Now().Format("20060102150405")
}